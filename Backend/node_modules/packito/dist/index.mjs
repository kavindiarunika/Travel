import chalk from 'chalk';
import emoji from 'node-emoji';
import minimist from 'minimist';
import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';

var name = "packito";
var version = "0.5.0";
var description = "clean your package before publishing it !";
var main = "dist/index.js";
var module = "dist/index.mjs";
var repository = "https://github.com/mikbry/packito.git";
var bugs = "https://github.com/mikbry/packito/issues";
var homepage = "https://github.com/mikbry/packito";
var author = "Mik <mik@miklabs.com>";
var license = "MIT";
var scripts = {
	build: "rollup -c && ./bin/packito.js",
	dev: "rollup -c  &&  cross-env NODE_ENV=development node ./dist",
	lint: "$(yarn bin)/eslint src",
	test: "cross-env NODE_ENV=test  $(yarn bin)/mocha  --require esm",
	coverage: "cross-env NODE_ENV=test  $(yarn bin)/nyc  _mocha",
	"report-coverage": "$(yarn bin)/nyc report --reporter=text-lcov > coverage.lcov",
	prepublishOnly: "yarn build"
};
var bin = {
	packito: "./bin/packito.js"
};
var engines = {
	node: ">=10"
};
var dependencies = {
	chalk: "^3.0.0",
	minimist: "^1.2.0",
	"node-emoji": "^1.10.0"
};
var devDependencies = {
	"@commitlint/cli": "^8.2.0",
	"@commitlint/config-conventional": "^8.2.0",
	"@rollup/plugin-json": "^4.0.0",
	"@rollup/plugin-node-resolve": "^6.0.0",
	chai: "^4.2.0",
	"cross-env": "^6.0.3",
	eslint: "^6.7.2",
	"eslint-config-airbnb-base": "^14.0.0",
	"eslint-config-prettier": "^6.7.0",
	"eslint-plugin-import": "^2.19.1",
	"eslint-plugin-jest": "^23.1.1",
	"eslint-plugin-prettier": "^3.1.1",
	esm: "^3.2.25",
	husky: "^3.1.0",
	mocha: "^6.2.2",
	nodemon: "^2.0.1",
	nyc: "^14.1.1",
	prettier: "^1.19.1",
	rimraf: "^3.0.0",
	rollup: "^1.27.9"
};
var husky = {
	hooks: {
		"pre-commit": "yarn lint",
		"commit-msg": "[[ -n $HUSKY_BYPASS ]] || commitlint -E HUSKY_GIT_PARAMS"
	},
	commitlint: {
		"extends": [
			"@commitlint/config-conventional"
		]
	}
};
var pkg = {
	name: name,
	version: version,
	description: description,
	main: main,
	module: module,
	repository: repository,
	bugs: bugs,
	homepage: homepage,
	author: author,
	license: license,
	scripts: scripts,
	bin: bin,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	husky: husky
};

/**
 * Copyright (c) 2019-present, Mik BRY
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const getPackage = () => pkg;

/**
 * Copyright (c) 2019-present, Mik BRY
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const aspawn = async (exe, args, opts, con = console) =>
  new Promise((resolve, reject) => {
    const proc = spawn(exe, args, opts);

    proc.stdout.on('data', buf => con.log(buf.toString()));
    proc.stderr.on('data', buf => con.error(buf.toString()));

    proc.on('error', reject);
    proc.on('close', code => {
      resolve({
        code,
      });
    });
  });

/**
 * Copyright (c) Mik BRY
 * mik@miklabs.com
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const fsp = fs.promises;

class Packito {
  constructor(outputDir, noPublish, publisherArguments) {
    this.outputDir = outputDir;
    this.noPublish = noPublish;
    this.publisherArguments = publisherArguments;
  }

  async readJSONFile(fileName, dir = './') {
    const f = path.join(dir, fileName);
    let filehandle = null;
    let result = null;
    try {
      filehandle = await fsp.open(f, 'r');
      const raw = await filehandle.readFile();
      result = JSON.parse(raw);
    } catch (error) {
      this.error = error;
    } finally {
      if (filehandle) {
        await filehandle.close();
      }
    }
    return result;
  }

  async readOptions(optionsFile = '.packito.json', dir = './') {
    let options = await this.readJSONFile(optionsFile, dir);
    if (!options) {
      // Default options
      options = {
        remove: {
          devDependencies: '*',
          script: '*',
        },
        copy: ['README.md', 'LICENSE'],
      };
    }
    this.options = options;
    return options;
  }

  async transform(_pkg, _options) {
    const pkg = _pkg || (await this.readJSONFile('package.json'));
    const options = _options || (await this.readOptions());
    const { remove, replace } = options;
    if (typeof remove === 'object') {
      Object.keys(remove).forEach(e => {
        if (remove[e] || remove[e] === '*') {
          delete pkg[e];
        }
      });
    }
    if (typeof replace === 'object') {
      Object.keys(replace).forEach(e => {
        if (replace[e]) {
          pkg[e] = replace[e];
        }
      });
    }
    if (typeof options.publisher === 'object') {
      this.publisher = options.publisher;
    } else if (typeof options.publisher === 'string') {
      this.publisher = { name: options.publisher };
    }
    this.pkg = pkg;
    this.data = JSON.stringify(this.pkg, null, '\t');
    // TODO handle publisher
    return this.pkg;
  }

  async copyRecursive(file, outputDir) {
    try {
      await fsp.copyFile(file, path.join(outputDir, path.basename(file)));
    } catch (error) {
      if (error.code === 'EISDIR') {
        const files = await fsp.readdir(file);
        await Promise.all(files.map(f => this.copyRecursive(path.join(file, f), path.join(outputDir, file))));
      }
    }
  }

  async write(packageFile = 'package.json') {
    let filehandle = null;
    let outputDir = this.options ? this.options.output : undefined;
    if (!outputDir) {
      ({ outputDir } = this);
    }
    try {
      await fsp.mkdir(outputDir, { recursive: true });
    } catch (error) {
      //
    }
    try {
      const f = path.join(outputDir, packageFile);
      // TODO test if outputDir exist
      filehandle = await fsp.open(f, 'w');
      await filehandle.writeFile(this.data);
    } catch (error) {
      this.error = error;
    } finally {
      if (filehandle) {
        await filehandle.close();
      }
    }
    if (this.options && Array.isArray(this.options.copy)) {
      await Promise.all(this.options.copy.map(e => this.copyRecursive(e, outputDir)));
    }
  }

  async publish(con) {
    if (!this.noPublish && (this.publisher || this.publisherArguments)) {
      let [exe, ...args] = this.publisherArguments || [];
      if (!exe) {
        [exe, ...args] = this.publisher.name.split(' ');
      }
      return aspawn(exe, args, undefined, con);
    }
    return { code: -1 };
  }
}

/**
 * Copyright (c) 2019-present, Mik BRY
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

class PackitoCli {
  constructor(args, output, exit) {
    this.output = output;
    this.args = args;
    this.exit = exit;
    this.chalk = chalk;
    this.options = {
      string: ['dist'],
      boolean: ['nopublish', 'help'],
      stopEarly: true,
      alias: {
        d: 'dist',
        n: 'nopublish',
        h: 'help',
      },
      default: {
        dist: './dist',
        nopublish: false,
        help: false,
      },
    };
  }

  log(text, ...opts) {
    this.output.log(text, ...opts);
  }

  error(text, ...opts) {
    this.output.error(text, ...opts);
  }

  header() {
    const { version } = getPackage();
    this.log(chalk.bold(emoji.emojify(`Packito cleans package before publishing v${version}`)));
  }

  usage() {
    this.log('Usage: $ packito [options] [bin-to-publisher]');
  }

  help() {
    this.usage();
    this.log('');
    this.log('Displays help informations.');
    this.log('');
    this.log('Options:');
    this.log('-d, --dist               Path to publish from');
    this.log('-n, --nopublish          Skips publishing step');
    this.log('-h, --help               Displays help informations');
    this.log('');
    this.log('Bin to publisher:');
    this.log('npm                      Publish using npm.');
    this.log('lerna                    Publish using lerna.');
    this.log('np                       Publish using np.');
    this.log('');
    this.log('Examples:');
    this.log('$ packito');
    this.log('$ packito -d ./publish');
    this.log('$ packito -d ./publish np patch');
  }

  async execute() {
    this.hrstart = process.hrtime();
    this.header();
    const args = minimist(this.args, this.options);
    if (args.help) {
      // Display help
      this.help();
    } else {
      // WIP execute
      const packito = new Packito(args.dist, args.n, args._);
      await packito.transform();
      await packito.write();
      // this.log('args=', args);
    }
  }
}
/* istanbul ignore next */
const start = async (output = console) => {
  const version = process.versions.node;
  const major = parseInt(version.split('.')[0], 10);

  if (major < 10) {
    output.error(`Node version ${version} is not supported, please use Node.js 10.0 or higher.`);
    process.exit(1);
  }

  // Grab arguments
  const [, , ...args] = process.argv;
  const cli = new PackitoCli(args, output, process.exit);
  await cli.execute();
  return cli;
};

/**
 * Copyright (c) Mik BRY
 * mik@miklabs.com
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(async () => start())();
//# sourceMappingURL=index.mjs.map
